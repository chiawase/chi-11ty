/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => lineArrange
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  myLocale: "",
  // An empty string uses the system default locale.
  preserveBlankLines: false
};
var lineArrange = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    /**
     * @property {Map<string, { renderedText: string, width: number }>} renderCache
     * A cache to store the results of expensive rendering and width calculation operations.
     * The key is a combination of the font specification and the source line (`${fontSpec}||${src}`),
     * ensuring that results are unique to both the text and the font used to measure it.
     */
    this.renderCache = /* @__PURE__ */ new Map();
    /**
     * Reference to the CSS event for cache invalidation.
     */
    this.cssEventRef = null;
    /**
     * @property headingScales
     * A cache of heading scale factors (relative to normal text size).
     * Keys: heading level 1–6. Values: number scale factor.
     */
    this.headingScales = null;
  }
  /**
   * The `onload` method is called when the plugin is enabled.
   * It loads settings and registers all commands and the settings tab.
   */
  async onload() {
    await this.loadSettings();
    this.cssEventRef = this.app.workspace.on("css-change", () => {
      this.renderCache.clear();
      this.headingScales = null;
      console.log("[LineArrange] CSS change \u2192 invalidated caches");
    });
    const runAsync = (fn) => (editor) => {
      fn(editor).catch(console.error);
    };
    this.addCommand({ id: "lexisort-lines", name: "Lexisort lines", editorCallback: runAsync(async (ed) => ed.replaceSelection(await this.lexisortLines(ed.getSelection()))) });
    this.addCommand({ id: "reverse-lines", name: "Reverse lines", editorCallback: runAsync(async (ed) => ed.replaceSelection(await this.reverseLines(ed.getSelection()))) });
    this.addCommand({ id: "sort-lines", name: "Sort lines", editorCallback: runAsync(async (ed) => ed.replaceSelection(await this.sortLines(ed.getSelection()))) });
    this.addCommand({ id: "shuffle-lines", name: "Shuffle lines", editorCallback: runAsync(async (ed) => ed.replaceSelection(await this.shuffleLines(ed.getSelection()))) });
    this.addCommand({ id: "lexisort-blocks", name: "Lexisort blocks", editorCallback: runAsync(async (ed) => ed.replaceSelection(await this.lexisortBlocks(ed.getSelection()))) });
    this.addCommand({ id: "reverse-blocks", name: "Reverse blocks", editorCallback: runAsync(async (ed) => ed.replaceSelection(await this.reverseBlocks(ed.getSelection()))) });
    this.addCommand({ id: "sort-blocks", name: "Sort blocks", editorCallback: runAsync(async (ed) => ed.replaceSelection(await this.sortBlocks(ed.getSelection()))) });
    this.addCommand({ id: "shuffle-blocks", name: "Shuffle blocks", editorCallback: runAsync(async (ed) => ed.replaceSelection(await this.shuffleBlocks(ed.getSelection()))) });
    this.addCommand({ id: "lexisort-headings", name: "Lexisort headings", editorCallback: runAsync(async (ed) => ed.replaceSelection(await this.lexisortHeadings(ed.getSelection()))) });
    this.addCommand({ id: "sort-headings", name: "Sort headings", editorCallback: runAsync(async (ed) => ed.replaceSelection(await this.sortHeadings(ed.getSelection()))) });
    this.addCommand({ id: "shuffle-headings", name: "Shuffle headings", editorCallback: runAsync(async (ed) => ed.replaceSelection(await this.shuffleHeadings(ed.getSelection()))) });
    this.addCommand({ id: "reverse-headings", name: "Reverse headings", editorCallback: runAsync(async (ed) => ed.replaceSelection(await this.reverseHeadings(ed.getSelection()))) });
    this.addSettingTab(new MySettingsTab(this.app, this));
  }
  /**
   * The `onunload` method is called when the plugin is disabled.
   */
  onunload() {
    if (this.cssEventRef) {
      this.app.workspace.offref(this.cssEventRef);
      this.cssEventRef = null;
    }
  }
  /**
   * Loads plugin settings from Obsidian's storage.
   */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /**
   * Saves the current plugin settings to Obsidian's storage.
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Returns true when the value is empty (meaning "use system default")
   * or when the BCP-47 tag is syntactically valid and supported by the engine.
   */
  isValidLocale(tag) {
    const t = (tag || "").trim();
    if (typeof Intl === "undefined" || !Intl.Collator || !Intl.getCanonicalLocales) {
      return false;
    }
    try {
      const canonical = Intl.getCanonicalLocales(t)[0];
      const supported = Intl.Collator.supportedLocalesOf([canonical], { localeMatcher: "lookup" });
      return supported.length > 0;
    } catch (e) {
      return false;
    }
  }
  /**
   * Gets the locale for string comparison, falling back to the browser/system language.
   */
  getLocale() {
    var _a;
    const loc = (_a = this.settings.myLocale) == null ? void 0 : _a.trim();
    return this.isValidLocale(loc) ? loc : navigator.language || "en";
  }
  /**
   * Gets the current theme font specification for text measurement.
   * @returns {string} A CSS font string using Obsidian's theme settings.
   */
  getFontSpec() {
    const size = getComputedStyle(document.body).getPropertyValue("--font-text-size") || "16px";
    const font = getComputedStyle(document.body).getPropertyValue("--font-text") || "sans-serif";
    return `${size.trim()} ${font.trim()}`;
  }
  /**
   * Initializes and returns the scale factor for a given heading level.
   * It measures <h1> through <h6> once using the browser's computed styles.
   * The cache is invalidated whenever the font specification changes.
   *
   * @param level - Heading level (1–6).
   * @returns Scale factor relative to normal text (e.g. 1.6 means 60% bigger).
   */
  getHeadingScale(level) {
    var _a;
    if (!this.headingScales) {
      this.headingScales = {};
      const baseSizePx = parseFloat(getComputedStyle(document.body).fontSize) || 16;
      for (let lvl = 1; lvl <= 6; lvl++) {
        const tmp = document.createElement(`h${lvl}`);
        tmp.style.visibility = "hidden";
        tmp.style.position = "absolute";
        tmp.textContent = "X";
        document.body.appendChild(tmp);
        const headingSizePx = parseFloat(getComputedStyle(tmp).fontSize);
        document.body.removeChild(tmp);
        let factor = 1;
        if (!isNaN(headingSizePx) && baseSizePx > 0) {
          factor = headingSizePx / baseSizePx;
        }
        this.headingScales[lvl] = factor;
      }
    }
    return (_a = this.headingScales[level]) != null ? _a : 1;
  }
  /** Implements the Fisher-Yates shuffle algorithm. */
  shuffleArray(arr) {
    const out = arr.slice();
    for (let i = out.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [out[i], out[j]] = [out[j], out[i]];
    }
    return out;
  }
  /** ------------------ Unified Cache ------------------ */
  /**
   * A unified function to get the rendered plain text and visual width of a line of Markdown.
   * It uses a cache to avoid re-calculating for the same line and font.
   * @param {string} src - The source Markdown line.
   * @returns {Promise<{ renderedText: string, width: number }>} An object containing the plain text and its calculated width.
   */
  async getRenderCacheEntry(src) {
    const fontSpec = this.getFontSpec().trim();
    const key = `${fontSpec}||${src}`;
    const cached = this.renderCache.get(key);
    if (cached)
      return cached;
    const tmp = document.createElement("div");
    const comp = new import_obsidian.Component();
    let rendered = "";
    try {
      const cleanSrc = src.replace(/^\s+/, "");
      await import_obsidian.MarkdownRenderer.render(this.app, cleanSrc, tmp, "", comp);
      rendered = tmp.innerText.trim() || cleanSrc;
    } finally {
      comp.unload();
    }
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    let width = rendered.length * 10;
    if (ctx) {
      ctx.font = fontSpec;
      width = ctx.measureText(rendered).width;
      const match = src.match(/^(#{1,6})\s+/);
      if (match) {
        const level = match[1].length;
        const scale = this.getHeadingScale(level);
        width *= scale;
      }
      width = Math.round(width * 1e4);
    }
    const entry = { renderedText: rendered, width };
    this.renderCache.set(key, entry);
    return entry;
  }
  /** ------------------ Line Helpers ------------------ */
  /**
   * A generic processor for line-based operations. It handles splitting text into lines
   * and managing blank lines according to the `preserveBlankLines` setting.
   * @param {string} orgText - The original text selection.
   * @param {(lines: string[]) => Promise<string[]>} orderer - An async function that takes an array of lines and returns them in a new order.
   * @returns {Promise<string>} The re-ordered text.
   */
  async processLines(orgText, orderer) {
    const lines = orgText.split("\n");
    if (!this.settings.preserveBlankLines) {
      const blanks = lines.filter((l) => l.trim() === "");
      const nonBlanks = lines.filter((l) => l.trim() !== "");
      const ordered = await orderer(nonBlanks);
      return [...blanks, ...ordered].join("\n").trimEnd();
    }
    const result = [];
    let buffer = [];
    const flush = async () => {
      if (buffer.length > 0) {
        const ordered = await orderer(buffer);
        result.push(...ordered);
        buffer = [];
      }
    };
    for (const line of lines) {
      if (line.trim() === "") {
        await flush();
        result.push(line);
      } else {
        buffer.push(line);
      }
    }
    await flush();
    return result.join("\n");
  }
  // --- Line command implementations ---
  async lexisortLines(orgText) {
    return this.processLines(orgText, async (lines) => {
      const entries = await Promise.all(lines.map((l) => this.getRenderCacheEntry(l)));
      const items = lines.map((line, i) => ({ line, rendered: entries[i].renderedText, i }));
      items.sort((a, b) => {
        const cmp = a.rendered.localeCompare(b.rendered, this.getLocale());
        return cmp !== 0 ? cmp : a.i - b.i;
      });
      return items.map((it) => it.line);
    });
  }
  async sortLines(orgText) {
    return this.processLines(orgText, async (lines) => {
      const entries = await Promise.all(lines.map((l) => this.getRenderCacheEntry(l)));
      const items = lines.map((line, i) => ({ line, width: entries[i].width, i }));
      items.sort((a, b) => a.width - b.width || a.i - b.i);
      return items.map((it) => it.line);
    });
  }
  async reverseLines(orgText) {
    return this.processLines(orgText, async (lines) => [...lines].reverse());
  }
  async shuffleLines(orgText) {
    return this.processLines(orgText, async (lines) => this.shuffleArray(lines));
  }
  /** ------------------ Block Helpers (for indented lists) ------------------ */
  // --- Block command implementations ---
  async sortBlocks(orgText) {
    const tree = this.buildTree(orgText.split("\n"));
    await this.sortTreeByWidth(tree);
    return this.flattenTree(tree).join("\n");
  }
  async lexisortBlocks(orgText) {
    const tree = this.buildTree(orgText.split("\n"));
    await this.lexiSortTree(tree);
    return this.flattenTree(tree).join("\n");
  }
  async reverseBlocks(orgText) {
    const tree = this.buildTree(orgText.split("\n"));
    await this.reverseTree(tree);
    return this.flattenTree(tree).join("\n");
  }
  async shuffleBlocks(orgText) {
    const tree = this.buildTree(orgText.split("\n"));
    await this.shuffleTree(tree);
    return this.flattenTree(tree).join("\n");
  }
  // --- Recursive tree sorters ---
  async sortTreeByWidth(node) {
    if (!node.children.length)
      return;
    const entries = await Promise.all(node.children.map((c) => this.getRenderCacheEntry(c.line || "")));
    const items = node.children.map((c, i) => ({ c, width: entries[i].width, i }));
    items.sort((a, b) => a.width - b.width || a.i - b.i);
    node.children = items.map((it) => it.c);
    for (const child of node.children)
      await this.sortTreeByWidth(child);
  }
  async lexiSortTree(node) {
    if (!node.children.length)
      return;
    const entries = await Promise.all(node.children.map((c) => this.getRenderCacheEntry(c.line || "")));
    const items = node.children.map((c, i) => ({ c, rendered: entries[i].renderedText, i }));
    items.sort((a, b) => {
      const cmp = a.rendered.localeCompare(b.rendered, this.getLocale());
      return cmp !== 0 ? cmp : a.i - b.i;
    });
    node.children = items.map((it) => it.c);
    for (const child of node.children)
      await this.lexiSortTree(child);
  }
  async reverseTree(node) {
    node.children.reverse();
    for (const child of node.children)
      await this.reverseTree(child);
  }
  async shuffleTree(node) {
    node.children = this.shuffleArray(node.children);
    for (const child of node.children)
      await this.shuffleTree(child);
  }
  /** ------------------ Tree Utils ------------------ */
  /**
   * Determines the hierarchical level of a line. Markdown Headings (#) have
   * levels 1-6. Indented lines are given higher levels (10+) to ensure they are
   * always treated as children of any heading.
   */
  getLevel(line) {
    const m = line.match(/^\s*(#+)\s/);
    return m ? m[1].length : 10 + this.getIndentation(line);
  }
  /** Calculates the number of leading whitespace characters. */
  getIndentation(line) {
    var _a, _b;
    return (_b = (_a = line.match(/^\s*/)) == null ? void 0 : _a[0].length) != null ? _b : 0;
  }
  /**
   * Converts a flat list of lines into a tree structure based on their levels.
   * This is the core of the "block" sorting logic.
   * @param {string[]} lines - The lines of text to process.
   * @returns {TreeNode} The root of the constructed tree.
   */
  buildTree(lines) {
    const root = new TreeNode(null, -1);
    const stack = [root];
    lines.forEach((line) => {
      const level = this.getLevel(line);
      const node = new TreeNode(line, level);
      while (stack[stack.length - 1].level >= level)
        stack.pop();
      stack[stack.length - 1].children.push(node);
      stack.push(node);
    });
    return root;
  }
  /**
   * Converts a tree structure back into a flat list of lines.
   */
  flattenTree(node) {
    const out = [];
    if (node.line !== null)
      out.push(node.line);
    node.children.forEach((c) => out.push(...this.flattenTree(c)));
    return out;
  }
  /** ------------------ Heading Helpers ------------------ */
  /**
   * A generic processor for heading-based operations. It splits the text into blocks,
   * where each block consists of a top-level heading and all the content following it.
   * @param {string} orgText - The original text selection.
   * @param {(blocks: Block[]) => Promise<Block[]>} orderer - An async function to re-order the blocks.
   * @returns {Promise<string>} The re-ordered text.
   */
  async transformHeadings(orgText, orderer) {
    const lines = orgText.split("\n");
    let minLevel = Infinity;
    for (const l of lines) {
      const m = l.match(/^(\s*#+)\s/);
      if (m)
        minLevel = Math.min(minLevel, m[1].trim().length);
    }
    if (minLevel === Infinity)
      return orgText;
    const blocks = [];
    let cur = null;
    for (const line of lines) {
      const m = line.match(/^(\s*#+)\s/);
      const lvl = m ? m[1].trim().length : null;
      if (lvl === minLevel) {
        if (cur)
          blocks.push(cur);
        cur = { heading: line, lines: [line] };
      } else {
        if (!cur)
          cur = { heading: "", lines: [] };
        cur.lines.push(line);
      }
    }
    if (cur)
      blocks.push(cur);
    const ordered = await orderer(blocks);
    return ordered.map((b) => b.lines.join("\n")).join("\n");
  }
  // --- Heading command implementations ---
  async lexisortHeadings(t) {
    return this.transformHeadings(t, async (blocks) => {
      const entries = await Promise.all(blocks.map((b) => this.getRenderCacheEntry(b.heading)));
      const items = blocks.map((b, i) => ({ b, rendered: entries[i].renderedText, i }));
      items.sort((a, b) => {
        const cmp = a.rendered.localeCompare(b.rendered, this.getLocale());
        return cmp !== 0 ? cmp : a.i - b.i;
      });
      return items.map((it) => it.b);
    });
  }
  async sortHeadings(t) {
    return this.transformHeadings(t, async (blocks) => {
      const entries = await Promise.all(blocks.map((b) => this.getRenderCacheEntry(b.heading)));
      const items = blocks.map((b, i) => ({ b, width: entries[i].width, i }));
      items.sort((a, b) => a.width - b.width || a.i - b.i);
      return items.map((it) => it.b);
    });
  }
  async reverseHeadings(t) {
    return this.transformHeadings(t, async (blocks) => blocks.slice().reverse());
  }
  async shuffleHeadings(t) {
    return this.transformHeadings(t, async (blocks) => this.shuffleArray(blocks.slice()));
  }
};
var TreeNode = class {
  constructor(line, level) {
    this.line = line;
    this.level = level;
    this.children = [];
  }
};
var MySettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Sorting Options" });
    new import_obsidian.Setting(containerEl).setName("Preserve Blanks (during line sorting)").setDesc("If enabled, blank lines remain in place. If disabled, blank lines are moved to the top during line operations.").addToggle((toggle) => toggle.setValue(this.plugin.settings.preserveBlankLines).onChange(async (value) => {
      this.plugin.settings.preserveBlankLines = value;
      await this.plugin.saveSettings();
    }));
    const quickLocales = ["en", "fr", "de", "es"];
    let initial = "custom";
    new import_obsidian.Setting(containerEl).setName("Text Locale").setDesc("Controls how text is compared when sorting (affects lexisort).").addDropdown((drop) => {
      var _a;
      drop.addOption("default", "System default");
      drop.addOption("en", "English (en)");
      drop.addOption("fr", "French (fr)");
      drop.addOption("de", "German (de)");
      drop.addOption("es", "Spanish (es)");
      drop.addOption("custom", "Custom\u2026");
      const cur = ((_a = this.plugin.settings.myLocale) == null ? void 0 : _a.trim()) || "";
      if (cur === "")
        initial = "default";
      else if (quickLocales.includes(cur))
        initial = cur;
      drop.setValue(initial);
      drop.onChange(async (value) => {
        if (value === "default") {
          this.plugin.settings.myLocale = "";
          await this.plugin.saveSettings();
        } else {
          this.plugin.settings.myLocale = value;
          await this.plugin.saveSettings();
        }
        this.display();
      });
    });
    if (initial === "custom") {
      new import_obsidian.Setting(containerEl).setName("Custom Locale").setDesc("Enter a BCP-47 locale (e.g. 'sv', 'ja'). Leave empty to use the system default.").addText((text) => {
        text.setPlaceholder("e.g. en-GB").setValue(this.plugin.isValidLocale(this.plugin.settings.myLocale) ? this.plugin.settings.myLocale : "").onChange(async (v) => {
          v = v.trim();
          if (this.plugin.isValidLocale(v)) {
            text.inputEl.style.border = "1px solid green";
            this.plugin.settings.myLocale = v;
          } else {
            text.inputEl.style.border = "1px solid red";
            this.plugin.settings.myLocale = "";
          }
          await this.plugin.saveSettings();
        });
      });
    }
  }
};

/* nosourcemap */